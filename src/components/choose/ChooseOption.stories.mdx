import { action } from '@storybook/addon-actions';
import { ArgsTable, Canvas, Meta, Story } from '@storybook/addon-docs';
import { ChooseOption } from './ChooseOption';


<Meta
    title="Component/Choose/ChooseOption"
    component={ChooseOption}
    argTypes={{
        options: { table: { category: 'Data' } },
        loading: { table: { category: 'Data' } },
        error: { table: { category: 'Data' } },
        selected: { table: { category: 'Data' } },
        extractor: { table: { category: 'Choose' } },
        onChoose: { table: { category: 'Choose' } },
        renderEmtpy: { table: { category: 'Renderers' } },
        renderGroupLabel: { table: { category: 'Renderers' } },
        renderOption: { table: { category: 'Renderers' } },
        className: { table: { category: 'Styling' } },
    }}
    parameters={{
        layout: 'centered'
    }}
/>

export const colors = [
    {
        name: 'Primary', options: [
            { value: 'ffff00', name: 'Yellow' },
            { value: '0000ff', name: 'Blue' },
            { value: 'ff0000', name: 'Red' }
        ]
    },
    {
        name: 'Secondary', options: [
            { value: '00ff00', name: 'Green' },
            { value: '800080', name: 'Purple' },
            { value: 'ffa500', name: 'Orange' }
        ]
    }
];


# ChooseOption

Component to choose from a list of options. When an option is clicked  the
`onChoose` callback is called with the option. Treat this component as an
unstyled `div`.

This component does not handle asynchronous loading of options, but
the `useSearchOptions` hook can be used to handle this.

This component does not handle keyboard navigation, but the
`useOptionsKeyNavigator` hook can be used to handle this.

The options are be provided in groups, so in the usual case, an array with the
array of options is required (note the double brackets at the begining and the
end): 

```js
[[ 'Yellow', 'Blue', 'Red' ]]
[[ 'Yellow', 'Blue', 'Red' ], [ 'Green', 'Purple', 'Orange' ]]
```

<Canvas>
    <Story name="Default" args={{ 
        options: colors,
        loading: false,
        error: false,
        selected: [1, 1],
        className: 'w-96 text-base border border-control-border rounded overflow-hidden'
    }}>
        {({ ...args }) => 
            <ChooseOption 
                {...args}
                extractor={(group) => group.options}
                onChoose={option => action('onChoose')(option)}
                renderEmtpy={() => 'No options'}
                renderGroupLabel={({ group }) => <span>{group.name}</span>}
                renderOption={({ option }) => <span className="lux-px-2em italic">{option.name}</span>}
            />
        }
    </Story>
</Canvas>

<ArgsTable story="Default"/>

## Data structure

This component assumes that options come in groups.If you don't want groups, 
you need to create one group with your options.Hence the basic data structure 
would be:

```js
const colors = [['Yellow', 'Blue', 'Red']];
```

Notice the actual options are inside another array, representing the first
group.Having two or more groups is very simple, just keep adding arrays:

```js
const colors = [['Yellow', 'Blue', 'Red'], ['Green', 'Purple', 'Orange']];
```

The structure can be enhanced by using objects for groups and options like this:

```js
const colors = [ 
    { 
        name: 'Primary', 
        options: [
            { value: 'ffff00', name: 'Yellow' },
            { value: '0000ff', name: 'Blue' },
            { value: 'ff0000', name: 'Red' }
        ] 
    },
    { 
        name: 'Secondary', 
        options: [
            { value: '00ff00', name: 'Green' },
            { value: '800080', name: 'Purple' },
            { value: 'ffa500', name: 'Orange' }
        ]
    }
];
```

When using these more complete data structures you need to provide one
extractor:

* __`extractor(group)`__: Get the options for the given group.This function
    returns the options associated to the provided group.In our case it would be
  something like`(group) => group.options`.__By default__ this extractor is 
  `(group) => group` which assumes that the options come in an array.

## HTML Structure

The `HTML` structure of `ChooseOption` is:

When is empty (undefined or null or empty array):

```html
<div ref={container} className={className}>
    {renderEmpty} <!-- rendered empty -->
<div>
```

When there is at least one option:

```html
<div ref={container} className={className}>
    <div>
        <div> <!-- group -->
            <div> <!-- rendered group label only if present -->
                {renderGroupLabel}
            <div>
            <ul>
                <li> <!-- rendered option -->
                    {renderOption}
                </li>
            <ul>
        </div>
    </div>
</div>
```

## Stories

This component only displays the groups, options, and selected option.If there
is loading or error nothing is rendered.

### When options are loading or there is an error

To get the simplest option list just pass an array of array of string options.

When `loading` or `error` nothing is rendered.

<Canvas>
    <Story name="Choose Option List With Loading">
        <ChooseOption
            options={[['Yellow', 'Blue', 'Red']]}
            loading={true}
            onChoose={option => action('onChoose')(option)}
            className="w-96 border border-control-border rounded overflow-hidden"
        />
    </Story>
</Canvas >

<Canvas>
    <Story name="Choose Option List With Error">
        <ChooseOption
            options={[['Yellow', 'Blue', 'Red']]}
            error={true}
            onChoose={option => action('onChoose')(option)}
            className="w-96 border border-control-border rounded overflow-hidden"
        />
    </Story>
</Canvas>

When there are no options nothing is rendered.

<Canvas>
    <Story name="Choose Option List No Options">
        <ChooseOption
            options={[[]]}
            onChoose={option => action('onChoose')(option)}
            className="w-96 border border-control-border rounded overflow-hidden"
        />
    </Story>
</Canvas >

When there are no options and a `renderEmtpy` function is passed, the result
of the function is rendered.

<Canvas>
    <Story name="Choose Option List No Options with Render">
        <ChooseOption
            options={[[]]}
            onChoose={option => action('onChoose')(option)}
            renderEmtpy={() => <div className="text-center">No options!</div>}
            className="w-96 border border-control-border rounded overflow-hidden"
        />
    </Story>
</Canvas >

But when `loading` or `error` nothing is rendered.

<Canvas>
    <Story name="Choose Option List With Loading or Error With No Options Render">
        <ChooseOption
            options={[[]]}
            loading={true}
            onChoose={option => action('onChoose')(option)}
            renderEmtpy={() => <div className="text-center">No options!</div>}
            className="w-96 border border-control-border rounded overflow-hidden"
        />
    </Story>
</Canvas >

When there are options.

<Canvas>
    <Story name="Choose Option List">
        <ChooseOption
            options={[['Yellow', 'Blue', 'Red']]}
            onChoose={option => action('onChoose')(option)}
            className="w-96 border border-control-border rounded overflow-hidden"
        />
    </Story>
</Canvas>

When there are two groups of options.

<Canvas>
    <Story name="Choose Option List with Group">
        <ChooseOption
            onChoose={option => action('onChoose')(option)}
            options={[['Yellow', 'Blue', 'Red'], ['Green', 'Purple', 'Orange']]}
            className="w-96 border border-control-border rounded overflow-hidden"
        />
    </Story>
</Canvas >

### When a selection is set

To show a selection of one of the options pass a non null `selected` property.

<Canvas>
    <Story name="Choose Option List with Selected">
        <ChooseOption
            options={[['Yellow', 'Blue', 'Red'], ['Green', 'Purple', 'Orange']]}
            selected={[0, 0]}
            onChoose={option => action('onChoose')(option)}
            className="w-96 border border-control-border rounded overflow-hidden"
        />
    </Story>
</Canvas >

The selection will be automatically be brought into view.

<Canvas>
    <Story name="Choose Option List with Selected and AutoScroll">
        <ChooseOption
            options={[['Yellow', 'Blue', 'Red'], ['Green', 'Purple', 'Orange']]}
            selected={[1, 2]}
            onChoose={option => action('onChoose')(option)}
            className="w-96 border border-control-border rounded overflow-hidden max-h-16 overflow-y-scroll"
        />
    </Story>
</Canvas >

### Different sizes

<Canvas>
    <Story name="Choose Option List Extra Small">
        <ChooseOption
            options={[['Yellow', 'Blue', 'Red']]}
            className="w-32 text-xs border border-control-border rounded overflow-hidden"
        />
    </Story>
    <Story name="Choose Option List Small">
        <ChooseOption
            options={[['Yellow', 'Blue', 'Red']]}
            className="w-32 text-sm border border-control-border rounded overflow-hidden"
        />
    </Story>
    <Story name="Choose Option List Base">
        <ChooseOption
            options={[['Yellow', 'Blue', 'Red']]}
            className="w-32 text-base border border-control-border rounded overflow-hidden"
        />
    </Story>
    <Story name="Choose Option List Large">
        <ChooseOption
            options={[['Yellow', 'Blue', 'Red']]}
            className="w-32 text-lg border border-control-border rounded overflow-hidden"
        />
    </Story>
    <Story name="Choose Option List Extra Large">
        <ChooseOption
            options={[['Yellow', 'Blue', 'Red']]}
            className="w-32 text-xl border border-control-border rounded overflow-hidden"
        />
    </Story>
    <Story name="Choose Option List Extra Extra Large">
        <ChooseOption
            options={[['Yellow', 'Blue', 'Red']]}
            className="w-32 text-2xl border border-control-border rounded overflow-hidden"
        />
    </Story>
</Canvas>

### Customized rendering

When the data gets more complicated you can provide the necessary options
extractor and rendering functions to render the list as you want.

<Canvas>
    <Story name="Choose Option List With Render">
        <ChooseOption
            options={[
                {
                    name: 'Primary', options: [
                        { value: 'ffff00', name: 'Yellow' },
                        { value: '0000ff', name: 'Blue' },
                        { value: 'ff0000', name: 'Red' }
                    ]
                },
                {
                    name: 'Secondary', options: [
                        { value: '00ff00', name: 'Green' },
                        { value: '800080', name: 'Purple' },
                        { value: 'ffa500', name: 'Orange' }
                    ]
                }
            ]}
            selected={[1, 2]}
            extractor={(group) => group.options}
            onChoose={option => action('onChoose')(option)}
            renderGroupLabel={({ group }) =>
                <div className="font-bold">
                    {group.name} ({group.options.length})
                </div>
            }
            renderOption={({ option }) =>
                <div className="flex flex-row justify-between items-center">
                    <span className="text-base">{option.name}</span>
                    <span className="text-sm text-gray-300">{option.value}</span>
                </div>
            }
            className="w-96 border border-control-border rounded overflow-hidden"
        />
    </Story>
</Canvas >
